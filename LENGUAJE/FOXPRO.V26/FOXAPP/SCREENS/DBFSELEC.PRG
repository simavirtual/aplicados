*       *********************************************************
*       *                                                         
*       * 05/05/94            DBFSELEC.SPR               13:57:11 
*       *                                                         
*       *********************************************************
*       *                                                         
*       * Walter J. Kennamer                                      
*       *                                                         
*       * Copyright (c) 1994 Microsoft Corp.                      
*       * One Microsoft Way                                       
*       * Redmond, WA  98027                                      
*       *                                                         
*       * Description:                                            
*       * This program was automatically generated by GENSCRN.    
*       *                                                         
*       *********************************************************

DO CASE
CASE _DOS OR _UNIX      && no UNIX records in screen

	
	#REGION 0
	REGIONAL m.currarea, m.talkstat, m.compstat
	
	IF SET("TALK") = "ON"
		SET TALK OFF
		m.talkstat = "ON"
	ELSE
		m.talkstat = "OFF"
	ENDIF
	m.compstat = SET("COMPATIBLE")
	SET COMPATIBLE FOXPLUS
	
	*       *********************************************************
	*       *                                                         
	*       *                MS-DOS Window definitions                
	*       *                                                         
	*       *********************************************************
	*
	
	IF NOT WEXIST("dbfselec") ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.PJX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.SCX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.MNX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.PRG" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.FRX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.QPR"
		DEFINE WINDOW dbfselec ;
			FROM INT((SROW()-17)/2),INT((SCOL()-38)/2) ;
			TO INT((SROW()-17)/2)+16,INT((SCOL()-38)/2)+37 ;
			TITLE " Tablas relacionadas " ;
			FLOAT ;
			NOCLOSE ;
			SHADOW ;
			NOMINIMIZE ;
			DOUBLE ;
			COLOR SCHEME 5
	ENDIF
	
	
	*       *********************************************************
	*       *                                                         
	*       *         DBFSELEC/MS-DOS Setup Code - SECTION 2          
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	* Save the databases, etc. that are open so that we can restore
	* the environment properly if the user opens a lot of databases
	* (by adding them to the relations) and then presses cancel.
	CREATE VIEW dbfselec.vue
	
	IF TYPE('DBFLIST') = 'U'
	   IF m.nextdbf = 0
	
	      DO initdbflist
	
	      * Default main database to the one that is currently open
	      IF !EMPTY(ALIAS())
	         dbflist[1,m.cstemnum] = ALIAS()
	         dbflist[1,m.cdbfnum]  = FULLPATH(DBF())
	         m.nextdbf = 2
	      ELSE
	         * If none currently open (shouldn't happen), prompt for one
	         m.newdbf = GETFILE("DBF","Tabla a abrir:")
	         IF !EMPTY(m.newdbf)
	            dbflist[1,m.cstemnum] = makealias(juststem(m.newdbf))
	            dbflist[1,m.cdbfnum] = m.newdbf
	
	            IF USED(dbflist[1,m.cstemnum])
	               SELECT (dbflist[1,m.cstemnum])
	            ELSE
	               SELECT 0
	               USE (m.newdbf)
	            ENDIF
	         ELSE
	            RETURN
	         ENDIF
	         m.nextdbf = 1
	      ENDIF
	      m.dbfselec = 1
	   ENDIF
	ELSE   && figure out which is the next available DBFlist slot
	   FOR i = 1 TO m.numareas
	      IF EMPTY(dbflist[i,m.cstemnum]) OR dbflist[i,m.cstemnum] = '\'
	         m.nextdbf = i
	         EXIT
	      ENDIF
	   ENDFOR
	ENDIF
	
	* Store the current dbflist in "origdbflist" so that we can restore it
	* if "cancel" is pressed.  Also store the current "nextdbf" value.
	RELEASE origdbflist                        && if it already exists
	PUBLIC origdbflist[m.numareas,m.numcols]
	=ACOPY(dbflist,origdbflist)
	orignextdbf = nextdbf
	
	
	
	*       *********************************************************
	*       *                                                         
	*       *              DBFSELEC/MS-DOS Screen Layout              
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	IF WVISIBLE("dbfselec")
		ACTIVATE WINDOW dbfselec SAME
	ELSE
		ACTIVATE WINDOW dbfselec NOSHOW
	ENDIF
	@ 1,2 GET dbfselec ;
	 	PICTURE "@&N" ;
		FROM dbflist ;
		SIZE 12,20 ;
		DEFAULT 1 ;
		WHEN _qpr0twnto() ;
		VALID _qpr0twnz4() ;
		COLOR SCHEME 6
	@ 8,24 GET addclr ;
		PICTURE "@*VN A\<gregar;\<Eliminar" ;
		SIZE 1,10,0 ;
		DEFAULT 1 ;
		VALID _qpr0two4n()
	@ 4,24 GET okbut ;
		PICTURE "@*VT \!\<Aceptar;\?\<Cancelar" ;
		SIZE 1,10,0 ;
		DEFAULT 1 ;
		VALID _qpr0twoq7()
	@ 13,8 GET tree1 ;
		PICTURE "@*HN \<Mostrar como  rbol" ;
		SIZE 1,20,1 ;
		DEFAULT 1 ;
		VALID _qpr0twowa()
	@ 0,2 SAY "Tablas relacionadas" ;
		SIZE 1,19, 0
	@ 0,21 SAY ":" ;
		SIZE 1,1, 0
	
	IF NOT WVISIBLE("dbfselec")
		ACTIVATE WINDOW dbfselec
	ENDIF
	
	READ CYCLE MODAL ;
		ACTIVATE _qpr0twp4b() ;
		SHOW _qpr0twp4e() ;
		WITH treewind
	
	RELEASE WINDOW dbfselec
	
	#REGION 0
	IF m.talkstat = "ON"
		SET TALK ON
	ENDIF
	IF m.compstat = "ON"
		SET COMPATIBLE ON
	ENDIF
	
	
	*       *********************************************************
	*       *                                                         
	*       *              DBFSELEC/MS-DOS Cleanup Code               
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	* Get rid of the tree window if it is still around
	IF WEXIST('treewind')
	   RELEASE WINDOW treewind
	ENDIF
	

CASE _MAC

	
	#REGION 0
	REGIONAL m.currarea, m.talkstat, m.compstat
	
	IF SET("TALK") = "ON"
		SET TALK OFF
		m.talkstat = "ON"
	ELSE
		m.talkstat = "OFF"
	ENDIF
	m.compstat = SET("COMPATIBLE")
	SET COMPATIBLE FOXPLUS
	
	m.rborder = SET("READBORDER")
	SET READBORDER ON
	
	*       *********************************************************
	*       *                                                         
	*       *              Macintosh Window definitions               
	*       *                                                         
	*       *********************************************************
	*
	
	IF NOT WEXIST("dbfselec") ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.PJX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.SCX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.MNX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.PRG" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.FRX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.QPR"
		DEFINE WINDOW dbfselec ;
			AT  0.000, 0.000  ;
			SIZE 17.923,38.333 ;
			TITLE " Related Tables" ;
			FONT "Geneva", 10 ;
			FLOAT ;
			NOCLOSE ;
			SHADOW ;
			DOUBLE
		MOVE WINDOW dbfselec CENTER
	ENDIF
	
	
	*       *********************************************************
	*       *                                                         
	*       *        DBFSELEC/Macintosh Setup Code - SECTION 2        
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	* Save the databases, etc. that are open so that we can restore
	* the environment properly if the user opens a lot of databases
	* (by adding them to the relations) and then presses cancel.
	CREATE VIEW dbfselec.vue
	
	IF TYPE('DBFLIST') = 'U'
	   IF m.nextdbf = 0
	
	      DO initdbflist
	
	      * Default main database to the one that is currently open
	      IF !EMPTY(ALIAS())
	         dbflist[1,m.cstemnum] = ALIAS()
	         dbflist[1,m.cdbfnum]  = FULLPATH(DBF())
	         m.nextdbf = 2
	      ELSE
	         * If none currently open (shouldn't happen), prompt for one
	         m.newdbf = GETFILE("DBF","Database to open:")
	         IF !EMPTY(m.newdbf)
	            dbflist[1,m.cstemnum] = makealias(juststem(m.newdbf))
	            dbflist[1,m.cdbfnum] = m.newdbf
	
	            IF USED(dbflist[1,m.cstemnum])
	               SELECT (dbflist[1,m.cstemnum])
	            ELSE
	               SELECT 0
	               USE (m.newdbf)
	            ENDIF
	         ELSE
	            RETURN
	         ENDIF
	         m.nextdbf = 1
	      ENDIF
	      m.dbfselec = 1
	   ENDIF
	ELSE   && figure out which is the next available DBFlist slot
	   FOR i = 1 TO m.numareas
	      IF EMPTY(dbflist[i,m.cstemnum]) OR dbflist[i,m.cstemnum] = '\'
	         m.nextdbf = i
	         EXIT
	      ENDIF
	   ENDFOR
	ENDIF
	
	* Store the current dbflist in "origdbflist" so that we can restore it
	* if "cancel" is pressed.  Also store the current "nextdbf" value.
	RELEASE origdbflist                        && if it already exists
	PUBLIC origdbflist[m.numareas,m.numcols]
	=ACOPY(dbflist,origdbflist)
	orignextdbf = nextdbf
	
	
	
	*       *********************************************************
	*       *                                                         
	*       *            DBFSELEC/Macintosh Screen Layout             
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	IF WVISIBLE("dbfselec")
		ACTIVATE WINDOW dbfselec SAME
	ELSE
		ACTIVATE WINDOW dbfselec NOSHOW
	ENDIF
	@ 1.923,1.833 GET dbfselec ;
	 	PICTURE "@&N3" ;
		FROM dbflist ;
		SIZE 12.692,20.167 ;
		DEFAULT 1 ;
		FONT "Geneva", 10 ;
		WHEN _qpr0twq4p() ;
		VALID _qpr0twq8p()
	@ 6.462,24.333 GET addclr ;
		PICTURE "@*VN3 \<Add;\<Delete" ;
		SIZE 1.462,10.000,0.308 ;
		DEFAULT 1 ;
		FONT "Geneva", 10 ;
		STYLE "B" ;
		VALID _qpr0twqfy()
	@ 1.923,24.333 GET okbut ;
		PICTURE "@*VT3 \!\<OK;\?\<Cancel" ;
		SIZE 1.385,10.000,0.462 ;
		DEFAULT 1 ;
		FONT "Geneva", 10 ;
		STYLE "B" ;
		VALID _qpr0twr2a()
	@ 15.308,2.500 GET tree1 ;
		PICTURE "@*HN3 Show As \<Tree" ;
		SIZE 1.462,15.857,1.000 ;
		DEFAULT 1 ;
		FONT "Geneva", 10 ;
		STYLE "B" ;
		VALID _qpr0twr8o()
	@ 0.615,1.667 SAY "Related Tables:" ;
		FONT "Geneva", 10 ;
		STYLE "BT"
	
	IF NOT WVISIBLE("dbfselec")
		ACTIVATE WINDOW dbfselec
	ENDIF
	
	READ CYCLE MODAL ;
		ACTIVATE _qpr0twrfc() ;
		SHOW _qpr0twrff() ;
		WITH treewind
	
	RELEASE WINDOW dbfselec
	
	#REGION 0
	
	SET READBORDER &rborder
	
	IF m.talkstat = "ON"
		SET TALK ON
	ENDIF
	IF m.compstat = "ON"
		SET COMPATIBLE ON
	ENDIF
	
	
	*       *********************************************************
	*       *                                                         
	*       *             DBFSELEC/Macintosh Cleanup Code             
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	* Get rid of the tree window if it is still around
	IF WEXIST('treewind')
	   RELEASE WINDOW treewind
	ENDIF
	

CASE _WINDOWS

	
	#REGION 0
	REGIONAL m.currarea, m.talkstat, m.compstat
	
	IF SET("TALK") = "ON"
		SET TALK OFF
		m.talkstat = "ON"
	ELSE
		m.talkstat = "OFF"
	ENDIF
	m.compstat = SET("COMPATIBLE")
	SET COMPATIBLE FOXPLUS
	
	m.rborder = SET("READBORDER")
	SET READBORDER ON
	
	*       *********************************************************
	*       *                                                         
	*       *               Windows Window definitions                
	*       *                                                         
	*       *********************************************************
	*
	
	IF NOT WEXIST("dbfselec") ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.PJX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.SCX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.MNX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.PRG" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.FRX" ;
		OR UPPER(WTITLE("DBFSELEC")) == "DBFSELEC.QPR"
		DEFINE WINDOW dbfselec ;
			AT  0.000, 0.000  ;
			SIZE 17.923,38.333 ;
			TITLE " Tablas relacionadas " ;
			FONT "MS Sans Serif", 8 ;
			STYLE "B" ;
			FLOAT ;
			NOCLOSE ;
			SHADOW ;
			NOMINIMIZE ;
			DOUBLE ;
			COLOR RGB(,,,192,192,192)
		MOVE WINDOW dbfselec CENTER
	ENDIF
	
	
	*       *********************************************************
	*       *                                                         
	*       *         DBFSELEC/Windows Setup Code - SECTION 2         
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	* Save the databases, etc. that are open so that we can restore
	* the environment properly if the user opens a lot of databases
	* (by adding them to the relations) and then presses cancel.
	CREATE VIEW dbfselec.vue
	
	IF TYPE('DBFLIST') = 'U'
	   IF m.nextdbf = 0
	
	      DO initdbflist
	
	      * Default main database to the one that is currently open
	      IF !EMPTY(ALIAS())
	         dbflist[1,m.cstemnum] = ALIAS()
	         dbflist[1,m.cdbfnum]  = FULLPATH(DBF())
	         m.nextdbf = 2
	      ELSE
	         * If none currently open (shouldn't happen), prompt for one
	         m.newdbf = GETFILE("DBF","Base de datos a abrir:")
	         IF !EMPTY(m.newdbf)
	            dbflist[1,m.cstemnum] = makealias(juststem(m.newdbf))
	            dbflist[1,m.cdbfnum] = m.newdbf
	
	            IF USED(dbflist[1,m.cstemnum])
	               SELECT (dbflist[1,m.cstemnum])
	            ELSE
	               SELECT 0
	               USE (m.newdbf)
	            ENDIF
	         ELSE
	            RETURN
	         ENDIF
	         m.nextdbf = 1
	      ENDIF
	      m.dbfselec = 1
	   ENDIF
	ELSE   && figure out which is the next available DBFlist slot
	   FOR i = 1 TO m.numareas
	      IF EMPTY(dbflist[i,m.cstemnum]) OR dbflist[i,m.cstemnum] = '\'
	         m.nextdbf = i
	         EXIT
	      ENDIF
	   ENDFOR
	ENDIF
	
	* Store the current dbflist in "origdbflist" so that we can restore it
	* if "cancel" is pressed.  Also store the current "nextdbf" value.
	RELEASE origdbflist                        && if it already exists
	PUBLIC origdbflist[m.numareas,m.numcols]
	=ACOPY(dbflist,origdbflist)
	orignextdbf = nextdbf
	
	
	
	*       *********************************************************
	*       *                                                         
	*       *             DBFSELEC/Windows Screen Layout              
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	IF WVISIBLE("dbfselec")
		ACTIVATE WINDOW dbfselec SAME
	ELSE
		ACTIVATE WINDOW dbfselec NOSHOW
	ENDIF
	@ 1.923,1.833 GET dbfselec ;
	 	PICTURE "@&N" ;
		FROM dbflist ;
		SIZE 12.692,21.833 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "B" ;
		WHEN _qpr0twsie() ;
		VALID _qpr0twskv()
	@ 6.846,26.000 GET addclr ;
		PICTURE "@*VN Ag\<regar;\<Eliminar" ;
		SIZE 1.923,10.000,0.308 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "B" ;
		VALID _qpr0twsth()
	@ 1.846,26.000 GET okbut ;
		PICTURE "@*VT \!\<Aceptar;\?\<Cancelar" ;
		SIZE 1.846,10.000,0.462 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "B" ;
		VALID _qpr0twthd()
	@ 15.308,2.500 GET tree1 ;
		PICTURE "@*HN \<Mostrar como árbol" ;
		SIZE 1.923,20.833,1.000 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "B" ;
		VALID _qpr0twtnq()
	@ 0.692,1.667 SAY "Tablas relacionadas:" ;
		FONT "MS Sans Serif", 8 ;
		STYLE "BT"
	
	IF NOT WVISIBLE("dbfselec")
		ACTIVATE WINDOW dbfselec
	ENDIF
	
	READ CYCLE MODAL ;
		ACTIVATE _qpr0twtsr() ;
		SHOW _qpr0twtsu() ;
		WITH treewind
	
	RELEASE WINDOW dbfselec
	
	#REGION 0
	
	SET READBORDER &rborder
	
	IF m.talkstat = "ON"
		SET TALK ON
	ENDIF
	IF m.compstat = "ON"
		SET COMPATIBLE ON
	ENDIF
	
	
	*       *********************************************************
	*       *                                                         
	*       *              DBFSELEC/Windows Cleanup Code              
	*       *                                                         
	*       *********************************************************
	*
	
	#REGION 1
	* Get rid of the tree window if it is still around
	IF WEXIST('treewind')
	   RELEASE WINDOW treewind
	ENDIF
	

ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWNTO           dbfselec WHEN                      
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC,     Record Number:    2  
*       * Variable:            dbfselec                           
*       * Called By:           WHEN Clause                        
*       * Object Type:         List                               
*       * Snippet Number:      1                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twnto     &&  dbfselec WHEN
#REGION 1
IF dbfselec = 0
   dbfselec = m.nextdbf - 1
   SHOW GET dbfselec
ENDIF

DO CASE
CASE dbfselec = 1
   SHOW GET addclr,2 DISABLE
CASE haschild(dbfselec)
   SHOW GET addclr,2 DISABLE
OTHERWISE
   SHOW GET addclr,2 ENABLE
ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWNZ4           dbfselec VALID                     
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC,     Record Number:    2  
*       * Variable:            dbfselec                           
*       * Called By:           VALID Clause                       
*       * Object Type:         List                               
*       * Snippet Number:      2                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twnz4     &&  dbfselec VALID
#REGION 1
DO CASE
CASE m.dbfselec = 0  && ignore a null selection
   * This shouldn't be possible because of the WHEN code,
   * but put the validation test in just to be sure.
   RETURN .F.
CASE m.dbfselec = 1
   WAIT WINDOW "Tabla principal." NOWAIT
CASE m.dbfselec > 1
   m.newdbf     = dbflist[m.dbfselec,m.cstemnum]
   m.childfld   = dbflist[m.dbfselec,m.cfldnum]
   m.childdbf   = dbflist[m.dbfselec,m.cdbfnum]
   m.parentfld  = dbflist[m.dbfselec,m.pfldnum]
   m.igncase    = .T.
   m.relstr     = dbflist[m.dbfselec,m.relstrnum]
   m.parentdbf  = dbflist[m.dbfselec,m.pdbfnum]
   m.addmode    = .F.    && we're editing an existing one

   * Find out how this database relates to the other ones.
   * Relselec will return an empty "childfld" if cancel was
   * pressed.
   DO relselec.spr WITH m.newdbf, m.childdbf, m.childfld, m.parentfld, ;
      m.igncase, m.relstr, m.parentdbf, m.addmode
   IF !EMPTY(m.childfld)
      * Record data about this child DBF on the DBFLIST
      dbflist[m.dbfselec,m.cstemnum]  = makealias(juststem(m.newdbf))
      dbflist[m.dbfselec,m.relstrnum] = m.relstr
      dbflist[m.dbfselec,m.pfldnum]   = m.parentfld
      dbflist[m.dbfselec,m.cfldnum]   = m.childfld
      dbflist[m.dbfselec,m.cdbfnum]   = m.childdbf
      dbflist[m.dbfselec,m.pdbfnum]   = m.parentdbf
   ENDIF
ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWO4N           addclr VALID                       
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC,     Record Number:    3  
*       * Variable:            addclr                             
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      3                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0two4n     &&  addclr VALID
#REGION 1
DO CASE
CASE m.addclr = 1   && add another database to the pot
   IF m.nextdbf >= m.numareas
      WAIT WINDOW "No quedan  reas de trabajo disponibles." NOWAIT
      RETURN
   ENDIF

   * Only accept DBF files, unless user cancels
   m.newdbf = "XXX"   && any value other than blank or a DBF file
   DO WHILE !EMPTY(m.newdbf) AND justext(m.newdbf) <> 'DBF'
      m.newdbf = GETFILE('DBF','Tabla a abrir:')
   ENDDO

   IF !EMPTY(m.newdbf)
      * Check for duplicate DBF stem name
      FOR i = 1 TO m.numareas
         IF makealias(juststem(m.newdbf)) == dbflist[i,m.cstemnum]
            WAIT WINDOW "No se permiten nombres de tabla duplicados." NOWAIT
            RETURN
         ENDIF
      ENDFOR

      m.childfld   = ""
      m.childdbf   = m.newdbf
      m.newdbf     = makealias(juststem(m.newdbf))
      m.parentfld  = ""
      m.igncase    = .T.
      m.relstr     = ""
      m.parentdbf  = ""

      * Find out how this database relates to the other ones.
      * Relselec will return an empty "childfld" if cancel was
      * pressed.
      DO relselec.spr WITH m.newdbf, m.childdbf, m.childfld, m.parentfld, ;
         m.igncase, m.relstr, m.parentdbf, .T.

      IF !EMPTY(m.childfld)  && true unless user cancelled RelSelec
         * Open the new child database
         IF USED(m.newdbf)
            SELECT (m.newdbf)
         ELSE
            SELECT 0
            USE (m.childdbf)
         ENDIF

         * See if we need to add a CDX or a tag on the relation field
         DO makecdx WITH (m.childdbf), (m.childfld)

         * Record data about this child DBF on the DBFLIST
         dbflist[m.nextdbf,m.cstemnum]  = makealias(juststem(m.newdbf))
         dbflist[m.nextdbf,m.relstrnum] = m.relstr
         dbflist[m.nextdbf,m.pfldnum]   = m.parentfld
         dbflist[m.nextdbf,m.cfldnum]   = m.childfld
         dbflist[m.nextdbf,m.cdbfnum]   = m.childdbf
         dbflist[m.nextdbf,m.pdbfnum]   = m.parentdbf
         dbflist[m.nextdbf,m.thefont]   = m.defaultfont
         dbflist[m.nextdbf,m.cascadenum]= m.defaultcasc

         * Come up with reasonable default positions for the database
         * browse window.  The "Arrange" option is how they will
         * usually be set.
         IF m.nextdbf > 2
            dbflist[m.nextdbf,m.srownum] ;
               = ALLTRIM(STR(VAL(dbflist[m.nextdbf-1,m.srownum])+1,3))
            dbflist[m.nextdbf,m.scolnum] ;
               = ALLTRIM(STR(VAL(dbflist[m.nextdbf,m.scolnum])+1,3))
         ELSE
            dbflist[m.nextdbf,m.srownum] = "1"
            dbflist[m.nextdbf,m.scolnum] = "1"
         ENDIF
         dbflist[m.nextdbf,m.erownum] = "6"
         dbflist[m.nextdbf,m.ecolnum] = "74"

         m.nextdbf  = m.nextdbf + 1
         m.dbfselec = m.nextdbf - 1
         SHOW GET arrange ENABLE
         SHOW GET addclr,2 ENABLE    && enable the "Clear" button
      ENDIF
   ENDIF
CASE m.addclr = 2    && clear this dbf
   DO CASE
   CASE m.dbfselec = 0   && choice was invalid
      RETURN .F.
   CASE m.dbfselec = 1
      WAIT WINDOW "No puede borrar la tabla principal." NOWAIT
      RETURN
   ENDCASE

   * See if this database has a child.  If so, don't allow it to be
   * cleared.  The clear button is also usually dimmed if the current
   * dbflist item has a child.
   IF haschild(m.dbfselec) AND !EMPTY(m.dbfselec)
      WAIT WINDOW "No puede borrar una tabla que tenga tablas relacionadas." NOWAIT
      RETURN
   ENDIF

   * Clear the DBF, assuming we are pointed at a valid DBF name.
   IF !EMPTY(dbflist[m.dbfselec,m.cstemnum]) AND dbflist[m.dbfselec,m.cstemnum] <> '\'
      * Close the database, if it is open (it should be)
      IF USED(makealias((TRIM(dbflist[m.dbfselec,m.cstemnum]))))
         m.aliasname = makealias(TRIM(dbflist[m.dbfselec,m.cstemnum]))
         SELECT (m.aliasname)
         USE
      ENDIF
      dbflist[m.dbfselec,m.cstemnum] = SPACE(25)
      DO CASE
      CASE m.nextdbf = 1                && no databases to close
      CASE m.dbfselec = m.nextdbf       && close the last one in the list
         m.nextdbf = m.nextdbf - 1
      OTHERWISE                         && close some other database
         = ADEL(dbflist,m.dbfselec)
         dbflist[m.numareas,m.cstemnum] = '\'  && disable this list item
         FOR i = 2 TO numcols
            dbflist[m.numareas,i] = ''
         ENDFOR
         m.nextdbf = m.nextdbf - 1
      ENDCASE
      m.dbfselec = m.nextdbf - 1

      SHOW GET dbfselec
   ENDIF
   IF m.nextdbf = 1
      SHOW GET arrange DISABLE
   ENDIF
ENDCASE
SHOW GETS


*       *********************************************************
*       *                                                         
*       * _QPR0TWOQ7           okbut VALID                        
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC,     Record Number:    4  
*       * Variable:            okbut                              
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      4                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twoq7     &&  okbut VALID
#REGION 1
IF okbut = 1
   IF relateddbfs()
      * Save the database relationships
      IF m.storersc
         * Tell user what is going on
         WAIT WINDOW "Guardando relaciones de tablas y posiciones de ventanas." NOWAIT

         DO putdbflist WITH dbflist[1,m.cstemnum]
      ENDIF

      WAIT CLEAR
   ENDIF
ELSE
   * Restore original DBFLIST array
   =ACOPY(origdbflist,dbflist)
   m.nextdbf = m.orignextdbf
   RELEASE origdbflist

   * Restore incoming environment
   IF FILE('dbfselec.vue')
      SET VIEW TO dbfselec.vue
   ENDIF
ENDIF

* Drop the view file
IF FILE('dbfselec.vue')
   DELETE FILE dbfselec.vue
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWOWA           tree1 VALID                        
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC,     Record Number:    5  
*       * Variable:            tree1                              
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      5                                  
*       *                                                         
*       *********************************************************
*
* Hide the tree diagram if it is visible; display it if it isn't
FUNCTION _qpr0twowa     &&  tree1 VALID
#REGION 1
IF WVISIBLE('treewind')
   RELEASE WINDOW treewind
   SHOW GET tree1,1 PROMPT "\<Mostrar  rbol"
ELSE
   IF m.nextdbf <= 1
      WAIT WINDOW "No hay  rbol que presentar" NOWAIT
   ELSE
      start_row = 3
      end_row   = MIN(start_row + 4 + m.nextdbf, SROWS()-1)
      start_col = 1
      end_col   = 20
      DEFINE WINDOW treewind ;
         FROM start_row,start_col TO end_row,end_col ;
         TITLE "µrbol de tablas" ;
         SYSTEM FLOAT NOZOOM NOCLOSE NOGROW ;
         COLOR SCHEME 10
      ACTIVATE WINDOW treewind NOSHOW
      SET CURSOR OFF
      DO showtree WITH 1,0
      ACTIVATE WINDOW treewind
      SHOW GET tree1,1 PROMPT "\<Ocultar  rbol"
   ENDIF
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWP4B           Read Level Activate                
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC                           
*       * Called By:           READ Statement                     
*       * Snippet Number:      6                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twp4b     && Read Level Activate
*
* Activate Code from screen: DBFSELEC
*
#REGION 1
IF nextdbf = 1
   SHOW GET arrange DISABLE
ELSE
   SHOW GET arrange ENABLE
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWP4E           Read Level Show                    
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       *                                                         
*       * From Platform:       MS-DOS                             
*       * From Screen:         DBFSELEC                           
*       * Called By:           READ Statement                     
*       * Snippet Number:      7                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twp4e     && Read Level Show
PRIVATE currwind
STORE WOUTPUT() TO currwind
*
* Show Code from screen: DBFSELEC
*
#REGION 1
IF nextdbf <= 2
   SHOW GET tree1 DISABLE
ELSE
   SHOW GET tree1 ENABLE
ENDIF
IF WVISIBLE('treewind')
   ACTIVATE WINDOW treewind NOSHOW
   CLEAR
   SET CURSOR OFF
   DO showtree WITH 1,0
   ACTIVATE WINDOW treewind
ENDIF

IF NOT EMPTY(currwind)
	ACTIVATE WINDOW (currwind) SAME
ENDIF

*       *********************************************************
*       *                                                         
*       * _QPR0TWQ4P           dbfselec WHEN                      
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC,     Record Number:   16  
*       * Variable:            dbfselec                           
*       * Called By:           WHEN Clause                        
*       * Object Type:         List                               
*       * Snippet Number:      8                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twq4p     &&  dbfselec WHEN
#REGION 1
IF dbfselec = 0
   dbfselec = m.nextdbf - 1
   SHOW GET dbfselec
ENDIF

DO CASE
CASE dbfselec = 1
   SHOW GET addclr,2 DISABLE
CASE haschild(dbfselec)
   SHOW GET addclr,2 DISABLE
OTHERWISE
   SHOW GET addclr,2 ENABLE
ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWQ8P           dbfselec VALID                     
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC,     Record Number:   16  
*       * Variable:            dbfselec                           
*       * Called By:           VALID Clause                       
*       * Object Type:         List                               
*       * Snippet Number:      9                                  
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twq8p     &&  dbfselec VALID
#REGION 1
DO CASE
CASE m.dbfselec = 0  && ignore a null selection
   * This shouldn't be possible because of the WHEN code,
   * but put the validation test in just to be sure.
   RETURN .F.
CASE m.dbfselec = 1
   WAIT WINDOW "Main database." NOWAIT
CASE m.dbfselec > 1
   m.newdbf     = dbflist[m.dbfselec,m.cstemnum]
   m.childfld   = dbflist[m.dbfselec,m.cfldnum]
   m.childdbf   = dbflist[m.dbfselec,m.cdbfnum]
   m.parentfld  = dbflist[m.dbfselec,m.pfldnum]
   m.igncase    = .T.
   m.relstr     = dbflist[m.dbfselec,m.relstrnum]
   m.parentdbf  = dbflist[m.dbfselec,m.pdbfnum]
   m.addmode    = .F.    && we're editing an existing one

   * Find out how this database relates to the other ones.
   * Relselec will return an empty "childfld" if cancel was
   * pressed.
   DO relselec.spr WITH m.newdbf, m.childdbf, m.childfld, m.parentfld, ;
      m.igncase, m.relstr, m.parentdbf, m.addmode
   IF !EMPTY(m.childfld)
      * Record data about this child DBF on the DBFLIST
      dbflist[m.dbfselec,m.cstemnum]  = makealias(juststem(m.newdbf))
      dbflist[m.dbfselec,m.relstrnum] = m.relstr
      dbflist[m.dbfselec,m.pfldnum]   = m.parentfld
      dbflist[m.dbfselec,m.cfldnum]   = m.childfld
      dbflist[m.dbfselec,m.cdbfnum]   = m.childdbf
      dbflist[m.dbfselec,m.pdbfnum]   = m.parentdbf
   ENDIF
ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWQFY           addclr VALID                       
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC,     Record Number:   17  
*       * Variable:            addclr                             
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      10                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twqfy     &&  addclr VALID
#REGION 1
DO CASE
CASE m.addclr = 1   && add another database to the pot
   IF m.nextdbf >= m.numareas
      WAIT WINDOW "There are no available work areas left." NOWAIT
      RETURN
   ENDIF

   * Only accept DBF files, unless user cancels
   m.newdbf = "XXX"   && any value other than blank or a DBF file
   DO WHILE !EMPTY(m.newdbf) AND justext(m.newdbf) <> 'DBF'
      m.newdbf = GETFILE('DBF','Database to open:')
   ENDDO

   IF !EMPTY(m.newdbf)
      * Check for duplicate DBF stem name
      FOR i = 1 TO m.numareas
         IF makealias(juststem(m.newdbf)) == dbflist[i,m.cstemnum]
            WAIT WINDOW "Duplicate database names are not allowed." NOWAIT
            RETURN
         ENDIF
      ENDFOR

      m.childfld   = ""
      m.childdbf   = m.newdbf
      m.newdbf     = makealias(juststem(m.newdbf))
      m.parentfld  = ""
      m.igncase    = .T.
      m.relstr     = ""
      m.parentdbf  = ""

      * Find out how this database relates to the other ones.
      * Relselec will return an empty "childfld" if cancel was
      * pressed.
      DO relselec.spr WITH m.newdbf, m.childdbf, m.childfld, m.parentfld, ;
         m.igncase, m.relstr, m.parentdbf, .T.

      IF !EMPTY(m.childfld)  && true unless user cancelled RelSelec
         * Open the new child database
         IF USED(m.newdbf)
            SELECT (m.newdbf)
         ELSE
            SELECT 0
            USE (m.childdbf)
         ENDIF

         * See if we need to add a CDX or a tag on the relation field
         DO makecdx WITH (m.childdbf), (m.childfld)

         * Record data about this child DBF on the DBFLIST
         dbflist[m.nextdbf,m.cstemnum]  = makealias(juststem(m.newdbf))
         dbflist[m.nextdbf,m.relstrnum] = m.relstr
         dbflist[m.nextdbf,m.pfldnum]   = m.parentfld
         dbflist[m.nextdbf,m.cfldnum]   = m.childfld
         dbflist[m.nextdbf,m.cdbfnum]   = m.childdbf
         dbflist[m.nextdbf,m.pdbfnum]   = m.parentdbf
         dbflist[m.nextdbf,m.thefont]   = m.defaultfont
         dbflist[m.nextdbf,m.cascadenum]= m.defaultcasc

         * Come up with reasonable default positions for the database
         * browse window.  The "Arrange" option is how they will
         * usually be set.
         IF m.nextdbf > 2
            dbflist[m.nextdbf,m.srownum] ;
               = ALLTRIM(STR(VAL(dbflist[m.nextdbf-1,m.srownum])+1,3))
            dbflist[m.nextdbf,m.scolnum] ;
               = ALLTRIM(STR(VAL(dbflist[m.nextdbf,m.scolnum])+1,3))
         ELSE
            dbflist[m.nextdbf,m.srownum] = "1"
            dbflist[m.nextdbf,m.scolnum] = "1"
         ENDIF
         dbflist[m.nextdbf,m.erownum] = "6"
         dbflist[m.nextdbf,m.ecolnum] = "74"

         m.nextdbf  = m.nextdbf + 1
         m.dbfselec = m.nextdbf - 1
         SHOW GET arrange ENABLE
         SHOW GET addclr,2 ENABLE    && enable the "Clear" button
      ENDIF
   ENDIF
CASE m.addclr = 2    && clear this dbf
   DO CASE
   CASE m.dbfselec = 0   && choice was invalid
      RETURN .F.
   CASE m.dbfselec = 1
      WAIT WINDOW "You cannot clear the main database." NOWAIT
      RETURN
   ENDCASE

   * See if this database has a child.  If so, don't allow it to be
   * cleared.  The clear button is also usually dimmed if the current
   * dbflist item has a child.
   IF haschild(m.dbfselec) AND !EMPTY(m.dbfselec)
      WAIT WINDOW "You cannot clear a database that has related databases." NOWAIT
      RETURN
   ENDIF

   * Clear the DBF, assuming we are pointed at a valid DBF name.
   IF !EMPTY(dbflist[m.dbfselec,m.cstemnum]) AND dbflist[m.dbfselec,m.cstemnum] <> '\'
      * Close the database, if it is open (it should be)
      IF USED(makealias((TRIM(dbflist[m.dbfselec,m.cstemnum]))))
         m.aliasname = makealias(TRIM(dbflist[m.dbfselec,m.cstemnum]))
         SELECT (m.aliasname)
         USE
      ENDIF
      dbflist[m.dbfselec,m.cstemnum] = SPACE(25)
      DO CASE
      CASE m.nextdbf = 1                && no databases to close
      CASE m.dbfselec = m.nextdbf       && close the last one in the list
         m.nextdbf = m.nextdbf - 1
      OTHERWISE                         && close some other database
         = ADEL(dbflist,m.dbfselec)
         dbflist[m.numareas,m.cstemnum] = '\'  && disable this list item
         FOR i = 2 TO numcols
            dbflist[m.numareas,i] = ''
         ENDFOR
         m.nextdbf = m.nextdbf - 1
      ENDCASE
      m.dbfselec = m.nextdbf - 1

      SHOW GET dbfselec
   ENDIF
   IF m.nextdbf = 1
      SHOW GET arrange DISABLE
   ENDIF
ENDCASE
SHOW GETS


*       *********************************************************
*       *                                                         
*       * _QPR0TWR2A           okbut VALID                        
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC,     Record Number:   18  
*       * Variable:            okbut                              
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      11                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twr2a     &&  okbut VALID
#REGION 1
IF okbut = 1
   IF relateddbfs()
      * Save the database relationships
      IF m.storersc
         * Tell user what is going on
         WAIT WINDOW "Saving database relations and window positions." NOWAIT

         DO putdbflist WITH dbflist[1,m.cstemnum]
      ENDIF

      WAIT CLEAR
   ENDIF
ELSE
   * Restore original DBFLIST array
   =ACOPY(origdbflist,dbflist)
   m.nextdbf = m.orignextdbf
   RELEASE origdbflist

   * Restore incoming environment
   IF FILE('dbfselec.vue')
      SET VIEW TO dbfselec.vue
   ENDIF
ENDIF

* Drop the view file
IF FILE('dbfselec.vue')
   DELETE FILE dbfselec.vue
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWR8O           tree1 VALID                        
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC,     Record Number:   19  
*       * Variable:            tree1                              
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      12                                 
*       *                                                         
*       *********************************************************
*
* Hide the tree diagram if it is visible; display it if it isn't
FUNCTION _qpr0twr8o     &&  tree1 VALID
#REGION 1
IF WVISIBLE('treewind')
   RELEASE WINDOW treewind
   SHOW GET tree1,1 PROMPT "\<Show tree"
ELSE
   IF m.nextdbf <= 1
      WAIT WINDOW "No tree to show!" NOWAIT
   ELSE
      start_row = 3
      end_row   = MIN(start_row + 4 + m.nextdbf, SROWS()-1)
      start_col = 1
      end_col   = 20
      DEFINE WINDOW treewind ;
         FROM start_row,start_col TO end_row,end_col ;
         TITLE "Database tree" ;
         SYSTEM FLOAT NOZOOM NOCLOSE NOGROW ;
         COLOR SCHEME 10
      ACTIVATE WINDOW treewind NOSHOW
      SET CURSOR OFF
      DO showtree WITH 1,0
      ACTIVATE WINDOW treewind
      SHOW GET tree1,1 PROMPT "\<Hide tree"
   ENDIF
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWRFC           Read Level Activate                
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC                           
*       * Called By:           READ Statement                     
*       * Snippet Number:      13                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twrfc     && Read Level Activate
*
* Activate Code from screen: DBFSELEC
*
#REGION 1
IF nextdbf = 1
   SHOW GET arrange DISABLE
ELSE
   SHOW GET arrange ENABLE
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWRFF           Read Level Show                    
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       *                                                         
*       * From Platform:       Macintosh                          
*       * From Screen:         DBFSELEC                           
*       * Called By:           READ Statement                     
*       * Snippet Number:      14                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twrff     && Read Level Show
PRIVATE currwind
STORE WOUTPUT() TO currwind
*
* Show Code from screen: DBFSELEC
*
#REGION 1
IF nextdbf <= 2
   SHOW GET tree1 DISABLE
ELSE
   SHOW GET tree1 ENABLE
ENDIF
IF WVISIBLE('treewind')
   ACTIVATE WINDOW treewind NOSHOW
   CLEAR
   SET CURSOR OFF
   DO showtree WITH 1,0
   ACTIVATE WINDOW treewind
ENDIF

IF NOT EMPTY(currwind)
	ACTIVATE WINDOW (currwind) SAME
ENDIF

*       *********************************************************
*       *                                                         
*       * _QPR0TWSIE           dbfselec WHEN                      
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC,     Record Number:    9  
*       * Variable:            dbfselec                           
*       * Called By:           WHEN Clause                        
*       * Object Type:         List                               
*       * Snippet Number:      15                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twsie     &&  dbfselec WHEN
#REGION 1
IF dbfselec = 0
   dbfselec = m.nextdbf - 1
   SHOW GET dbfselec
ENDIF

DO CASE
CASE dbfselec = 1
   SHOW GET addclr,2 DISABLE
CASE haschild(dbfselec)
   SHOW GET addclr,2 DISABLE
OTHERWISE
   SHOW GET addclr,2 ENABLE
ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWSKV           dbfselec VALID                     
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC,     Record Number:    9  
*       * Variable:            dbfselec                           
*       * Called By:           VALID Clause                       
*       * Object Type:         List                               
*       * Snippet Number:      16                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twskv     &&  dbfselec VALID
#REGION 1
DO CASE
CASE m.dbfselec = 0  && ignore a null selection
   * This shouldn't be possible because of the WHEN code,
   * but put the validation test in just to be sure.
   RETURN .F.
CASE m.dbfselec = 1
   WAIT WINDOW "Base de datos principal." NOWAIT
CASE m.dbfselec > 1
   m.newdbf     = dbflist[m.dbfselec,m.cstemnum]
   m.childfld   = dbflist[m.dbfselec,m.cfldnum]
   m.childdbf   = dbflist[m.dbfselec,m.cdbfnum]
   m.parentfld  = dbflist[m.dbfselec,m.pfldnum]
   m.igncase    = .T.
   m.relstr     = dbflist[m.dbfselec,m.relstrnum]
   m.parentdbf  = dbflist[m.dbfselec,m.pdbfnum]
   m.addmode    = .F.    && we're editing an existing one

   * Find out how this database relates to the other ones.
   * Relselec will return an empty "childfld" if cancel was
   * pressed.
   DO relselec.spr WITH m.newdbf, m.childdbf, m.childfld, m.parentfld, ;
      m.igncase, m.relstr, m.parentdbf, m.addmode
   IF !EMPTY(m.childfld)
      * Record data about this child DBF on the DBFLIST
      dbflist[m.dbfselec,m.cstemnum]  = makealias(juststem(m.newdbf))
      dbflist[m.dbfselec,m.relstrnum] = m.relstr
      dbflist[m.dbfselec,m.pfldnum]   = m.parentfld
      dbflist[m.dbfselec,m.cfldnum]   = m.childfld
      dbflist[m.dbfselec,m.cdbfnum]   = m.childdbf
      dbflist[m.dbfselec,m.pdbfnum]   = m.parentdbf
   ENDIF
ENDCASE


*       *********************************************************
*       *                                                         
*       * _QPR0TWSTH           addclr VALID                       
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC,     Record Number:   10  
*       * Variable:            addclr                             
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      17                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twsth     &&  addclr VALID
#REGION 1
DO CASE
CASE m.addclr = 1   && add another database to the pot
   IF m.nextdbf >= m.numareas
      WAIT WINDOW "No quedan áreas de trabajo disponibles." NOWAIT
      RETURN
   ENDIF

   * Only accept DBF files, unless user cancels
   m.newdbf = "XXX"   && any value other than blank or a DBF file
   DO WHILE !EMPTY(m.newdbf) AND justext(m.newdbf) <> 'DBF'
      m.newdbf = GETFILE('DBF','Base de datos a abrir:')
   ENDDO

   IF !EMPTY(m.newdbf)
      * Check for duplicate DBF stem name
      FOR i = 1 TO m.numareas
         IF makealias(juststem(m.newdbf)) == dbflist[i,m.cstemnum]
            WAIT WINDOW "No se permiten nombres de base de datos duplicados." NOWAIT
            RETURN
         ENDIF
      ENDFOR

      m.childfld   = ""
      m.childdbf   = m.newdbf
      m.newdbf     = makealias(juststem(m.newdbf))
      m.parentfld  = ""
      m.igncase    = .T.
      m.relstr     = ""
      m.parentdbf  = ""

      * Find out how this database relates to the other ones.
      * Relselec will return an empty "childfld" if cancel was
      * pressed.
      DO relselec.spr WITH m.newdbf, m.childdbf, m.childfld, m.parentfld, ;
         m.igncase, m.relstr, m.parentdbf, .T.

      IF !EMPTY(m.childfld)  && true unless user cancelled RelSelec
         * Open the new child database
         IF USED(m.newdbf)
            SELECT (m.newdbf)
         ELSE
            SELECT 0
            USE (m.childdbf)
         ENDIF

         * See if we need to add a CDX or a tag on the relation field
         DO makecdx WITH (m.childdbf), (m.childfld)

         * Record data about this child DBF on the DBFLIST
         dbflist[m.nextdbf,m.cstemnum]  = makealias(juststem(m.newdbf))
         dbflist[m.nextdbf,m.relstrnum] = m.relstr
         dbflist[m.nextdbf,m.pfldnum]   = m.parentfld
         dbflist[m.nextdbf,m.cfldnum]   = m.childfld
         dbflist[m.nextdbf,m.cdbfnum]   = m.childdbf
         dbflist[m.nextdbf,m.pdbfnum]   = m.parentdbf
         dbflist[m.nextdbf,m.thefont]   = m.defaultfont
         dbflist[m.nextdbf,m.cascadenum]= m.defaultcasc

         * Come up with reasonable default positions for the database
         * browse window.  The "Arrange" option is how they will
         * usually be set.
         IF m.nextdbf > 2
            dbflist[m.nextdbf,m.srownum] ;
               = ALLTRIM(STR(VAL(dbflist[m.nextdbf-1,m.srownum])+1,3))
            dbflist[m.nextdbf,m.scolnum] ;
               = ALLTRIM(STR(VAL(dbflist[m.nextdbf,m.scolnum])+1,3))
         ELSE
            dbflist[m.nextdbf,m.srownum] = "1"
            dbflist[m.nextdbf,m.scolnum] = "1"
         ENDIF
         dbflist[m.nextdbf,m.erownum] = "6"
         dbflist[m.nextdbf,m.ecolnum] = "74"

         m.nextdbf  = m.nextdbf + 1
         m.dbfselec = m.nextdbf - 1
         SHOW GET arrange ENABLE
         SHOW GET addclr,2 ENABLE    && enable the "Clear" button
      ENDIF
   ENDIF
CASE m.addclr = 2    && clear this dbf
   DO CASE
   CASE m.dbfselec = 0   && choice was invalid
      RETURN .F.
   CASE m.dbfselec = 1
      WAIT WINDOW "No puede borrar la base de datos principal." NOWAIT
      RETURN
   ENDCASE

   * See if this database has a child.  If so, don't allow it to be
   * cleared.  The clear button is also usually dimmed if the current
   * dbflist item has a child.
   IF haschild(m.dbfselec) AND !EMPTY(m.dbfselec)
      WAIT WINDOW "No puede borrar una base de datos que tenga bases de datos relacionadas." NOWAIT
      RETURN
   ENDIF

   * Clear the DBF, assuming we are pointed at a valid DBF name.
   IF !EMPTY(dbflist[m.dbfselec,m.cstemnum]) AND dbflist[m.dbfselec,m.cstemnum] <> '\'
      * Close the database, if it is open (it should be)
      IF USED(makealias((TRIM(dbflist[m.dbfselec,m.cstemnum]))))
         m.aliasname = makealias(TRIM(dbflist[m.dbfselec,m.cstemnum]))
         SELECT (m.aliasname)
         USE
      ENDIF
      dbflist[m.dbfselec,m.cstemnum] = SPACE(25)
      DO CASE
      CASE m.nextdbf = 1                && no databases to close
      CASE m.dbfselec = m.nextdbf       && close the last one in the list
         m.nextdbf = m.nextdbf - 1
      OTHERWISE                         && close some other database
         = ADEL(dbflist,m.dbfselec)
         dbflist[m.numareas,m.cstemnum] = '\'  && disable this list item
         FOR i = 2 TO numcols
            dbflist[m.numareas,i] = ''
         ENDFOR
         m.nextdbf = m.nextdbf - 1
      ENDCASE
      m.dbfselec = m.nextdbf - 1

      SHOW GET dbfselec
   ENDIF
   IF m.nextdbf = 1
      SHOW GET arrange DISABLE
   ENDIF
ENDCASE
SHOW GETS


*       *********************************************************
*       *                                                         
*       * _QPR0TWTHD           okbut VALID                        
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC,     Record Number:   11  
*       * Variable:            okbut                              
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      18                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twthd     &&  okbut VALID
#REGION 1
IF okbut = 1
   IF relateddbfs()
      * Save the database relationships
      IF m.storersc
         * Tell user what is going on
         WAIT WINDOW "Guardar las relaciones de la base de datos y las posiciones de las ventanas." NOWAIT

         DO putdbflist WITH dbflist[1,m.cstemnum]
      ENDIF

      WAIT CLEAR
   ENDIF
ELSE
   * Restore original DBFLIST array
   =ACOPY(origdbflist,dbflist)
   m.nextdbf = m.orignextdbf
   RELEASE origdbflist

   * Restore incoming environment
   IF FILE('dbfselec.vue')
      SET VIEW TO dbfselec.vue
   ENDIF
ENDIF

* Drop the view file
IF FILE('dbfselec.vue')
   DELETE FILE dbfselec.vue
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWTNQ           tree1 VALID                        
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC,     Record Number:   12  
*       * Variable:            tree1                              
*       * Called By:           VALID Clause                       
*       * Object Type:         Push Button                        
*       * Snippet Number:      19                                 
*       *                                                         
*       *********************************************************
*
* Hide the tree diagram if it is visible; display it if it isn't
FUNCTION _qpr0twtnq     &&  tree1 VALID
#REGION 1
IF WVISIBLE('treewind')
   RELEASE WINDOW treewind
   SHOW GET tree1,1 PROMPT "\<Mostrar árbol"
ELSE
   IF m.nextdbf <= 1
      WAIT WINDOW "¡No hay árbol que mostrar!" NOWAIT
   ELSE
      start_row = 3
      end_row   = MIN(start_row + 4 + m.nextdbf, SROWS()-1)
      start_col = 1
      end_col   = 20
      DEFINE WINDOW treewind ;
         FROM start_row,start_col TO end_row,end_col ;
         TITLE "Árbol de base de datos" ;
         SYSTEM FLOAT NOZOOM NOCLOSE NOGROW ;
         COLOR SCHEME 10
      ACTIVATE WINDOW treewind NOSHOW
      SET CURSOR OFF
      DO showtree WITH 1,0
      ACTIVATE WINDOW treewind
      SHOW GET tree1,1 PROMPT "\<Ocultar árbol"
   ENDIF
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWTSR           Read Level Activate                
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC                           
*       * Called By:           READ Statement                     
*       * Snippet Number:      20                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twtsr     && Read Level Activate
*
* Activate Code from screen: DBFSELEC
*
#REGION 1
IF nextdbf = 1
   SHOW GET arrange DISABLE
ELSE
   SHOW GET arrange ENABLE
ENDIF


*       *********************************************************
*       *                                                         
*       * _QPR0TWTSU           Read Level Show                    
*       *                                                         
*       * Function Origin:                                        
*       *                                                         
*       *                                                         
*       * From Platform:       Windows                            
*       * From Screen:         DBFSELEC                           
*       * Called By:           READ Statement                     
*       * Snippet Number:      21                                 
*       *                                                         
*       *********************************************************
*
FUNCTION _qpr0twtsu     && Read Level Show
PRIVATE currwind
STORE WOUTPUT() TO currwind
*
* Show Code from screen: DBFSELEC
*
#REGION 1
IF nextdbf <= 2
   SHOW GET tree1 DISABLE
ELSE
   SHOW GET tree1 ENABLE
ENDIF
IF WVISIBLE('treewind')
   ACTIVATE WINDOW treewind NOSHOW
   CLEAR
   SET CURSOR OFF
   DO showtree WITH 1,0
   ACTIVATE WINDOW treewind
ENDIF

IF NOT EMPTY(currwind)
	ACTIVATE WINDOW (currwind) SAME
ENDIF


*       *********************************************************
*       *                                                         
*       *  DBFSELEC/Windows Supporting Procedures and Functions   
*       *                                                         
*       *********************************************************
*

#REGION 1

*       *********************************************************
*       *                                                         
*       *               DBFSELEC Procedure ARRSAVE                
*       *                                                         
*       *********************************************************
*


PROCEDURE ARRSAVE
DO CASE
CASE _DOS
	* Save arrangement of windows and return to dbfselect screen
	
	* Set exit flag for READ VALID
	arrexflg = .T.
	
	* Record window coordinates and release all the application windows
	m.ctrlrow = INT(WLROW('CTRL'))
	m.ctrlcol = INT(WLCOL('CTRL'))
	RELEASE WINDOW ctrl
	
	FOR i = 1 TO m.numareas
	   IF !EMPTY(dbflist[i,m.cstemnum]) AND dbflist[i,m.cstemnum] <> '\'
	      dbflist[i,m.srownum] = ALLTRIM(STR(WLROW(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.scolnum] = ALLTRIM(STR(WLCOL(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.erownum] = ;
	         ALLTRIM(STR(VAL(dbflist[i,m.srownum]);
	         +1+wrow(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.ecolnum] = ;
	         ALLTRIM(STR(VAL(dbflist[i,m.scolnum]);
	         +1+wcol(dbflist[i,m.cstemnum]),3))
	      RELEASE WINDOW (dbflist[i,m.cstemnum])
	   ENDIF
	   dbflist[i,m.arranged] = "Y"
	ENDFOR
	
	* Restore environment
	POP MENU _msysmenu
	SHOW WINDOW appgen, dbfselec
	ACTIVATE WINDOW dbfselec
	
	CLEAR READ
	
	RETURN
	
	
	
	*!*****************************************************************
	*!
	*!      Procedure: ARREXIT
	*!
	*!*****************************************************************
CASE _WINDOWS
	* Save arrangement of windows and return to dbfselect screen
	
	* Set exit flag for READ VALID
	arrexflg = .T.
	
	* Record window coordinates and release all the application windows
	m.ctrlrow = INT(WLROW('CTRL'))
	m.ctrlcol = INT(WLCOL('CTRL'))
	RELEASE WINDOW ctrl
	
	FOR i = 1 TO m.numareas
	   IF !EMPTY(dbflist[i,m.cstemnum]) AND dbflist[i,m.cstemnum] <> '\'
	      dbflist[i,m.srownum] = ALLTRIM(STR(WLROW(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.scolnum] = ALLTRIM(STR(WLCOL(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.erownum] = ;
	         ALLTRIM(STR(VAL(dbflist[i,m.srownum]);
	         +1+wrow(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.ecolnum] = ;
	         ALLTRIM(STR(VAL(dbflist[i,m.scolnum]);
	         +1+wcol(dbflist[i,m.cstemnum]),3))
	      RELEASE WINDOW (dbflist[i,m.cstemnum])
	   ENDIF
	   dbflist[i,m.arranged] = "Y"
	ENDFOR
	
	* Restore environment
	POP MENU _msysmenu
	SHOW WINDOW appgen, dbfselec
	ACTIVATE WINDOW dbfselec
	
	CLEAR READ
	
	RETURN
	
	
	
	*!*****************************************************************
	*!
	*!      Procedure: ARREXIT
	*!
	*!*****************************************************************
CASE _MAC
	* Save arrangement of windows and return to dbfselect screen
	
	* Set exit flag for READ VALID
	arrexflg = .T.
	
	* Record window coordinates and release all the application windows
	m.ctrlrow = INT(WLROW('CTRL'))
	m.ctrlcol = INT(WLCOL('CTRL'))
	RELEASE WINDOW ctrl
	
	FOR i = 1 TO m.numareas
	   IF !EMPTY(dbflist[i,m.cstemnum]) AND dbflist[i,m.cstemnum] <> '\'
	      dbflist[i,m.srownum] = ALLTRIM(STR(WLROW(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.scolnum] = ALLTRIM(STR(WLCOL(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.erownum] = ;
	         ALLTRIM(STR(VAL(dbflist[i,m.srownum]);
	         +1+wrow(dbflist[i,m.cstemnum]),3))
	      dbflist[i,m.ecolnum] = ;
	         ALLTRIM(STR(VAL(dbflist[i,m.scolnum]);
	         +1+wcol(dbflist[i,m.cstemnum]),3))
	      RELEASE WINDOW (dbflist[i,m.cstemnum])
	   ENDIF
	   dbflist[i,m.arranged] = "Y"
	ENDFOR
	
	* Restore environment
	POP MENU _msysmenu
	SHOW WINDOW appgen, dbfselec
	ACTIVATE WINDOW dbfselec
	
	CLEAR READ
	
	RETURN
	
	
	
	*!*****************************************************************
	*!
	*!      Procedure: ARREXIT
	*!
	*!*****************************************************************
ENDCASE

*       *********************************************************
*       *                                                         
*       *               DBFSELEC Procedure ARREXIT                
*       *                                                         
*       *********************************************************
*


PROCEDURE ARREXIT
DO CASE
CASE _DOS
	* Exit without saving window positions
	
	* Set exit flag for READ VALID
	arrexflg = .T.
	
	* Release all the application windows
	RELEASE WINDOW ctrl
	FOR i = 1 TO m.numareas
	   IF !EMPTY(dbflist[i,m.cstemnum]) AND dbflist[i,m.cstemnum] <> '\'
	      RELEASE WINDOW (dbflist[i,m.cstemnum])
	   ENDIF
	ENDFOR
	
	* Restore environment
	POP MENU _msysmenu
	SHOW WINDOW appgen, dbfselec
	ACTIVATE WINDOW dbfselec
	
	CLEAR READ
	
	RETURN
	
	
	*!*****************************************************************
	*!
	*!      Procedure: HASCHILD
	*!
	*!*****************************************************************
CASE _WINDOWS
	* Exit without saving window positions
	
	* Set exit flag for READ VALID
	arrexflg = .T.
	
	* Release all the application windows
	RELEASE WINDOW ctrl
	FOR i = 1 TO m.numareas
	   IF !EMPTY(dbflist[i,m.cstemnum]) AND dbflist[i,m.cstemnum] <> '\'
	      RELEASE WINDOW (dbflist[i,m.cstemnum])
	   ENDIF
	ENDFOR
	
	* Restore environment
	POP MENU _msysmenu
	SHOW WINDOW appgen, dbfselec
	ACTIVATE WINDOW dbfselec
	
	CLEAR READ
	
	RETURN
	
	
	*!*****************************************************************
	*!
	*!      Procedure: HASCHILD
	*!
	*!*****************************************************************
CASE _MAC
	* Exit without saving window positions
	
	* Set exit flag for READ VALID
	arrexflg = .T.
	
	* Release all the application windows
	RELEASE WINDOW ctrl
	FOR i = 1 TO m.numareas
	   IF !EMPTY(dbflist[i,m.cstemnum]) AND dbflist[i,m.cstemnum] <> '\'
	      RELEASE WINDOW (dbflist[i,m.cstemnum])
	   ENDIF
	ENDFOR
	
	* Restore environment
	POP MENU _msysmenu
	SHOW WINDOW appgen, dbfselec
	ACTIVATE WINDOW dbfselec
	
	CLEAR READ
	
	RETURN
	
	
	*!*****************************************************************
	*!
	*!      Procedure: HASCHILD
	*!
	*!*****************************************************************
ENDCASE

*       *********************************************************
*       *                                                         
*       *               DBFSELEC Function HASCHILD                
*       *                                                         
*       *********************************************************
*


PROCEDURE HASCHILD
PARAMETERS DBFNUM
DO CASE
CASE _DOS
	* Does the database at position "dbfnum" of DBFLIST have a child
	* table?
	PRIVATE dbfnum, i
	
	* See if another database has this one as its parent
	FOR m.i = 1 TO m.numareas
	   IF makealias(ALLTRIM(dbflist[m.i,m.pdbfnum])) ;
	         == makealias(ALLTRIM(dbflist[m.dbfnum,m.cstemnum]))
	      RETURN .T.
	   ENDIF
	ENDFOR
	RETURN .F.
	
	*!*****************************************************************
	*!
	*!      Procedure: SHOWTREE
	*!
	*!*****************************************************************
CASE _WINDOWS
	* Does the database at position "dbfnum" of DBFLIST have a child
	* table?
	PRIVATE dbfnum, i
	
	* See if another database has this one as its parent
	FOR m.i = 1 TO m.numareas
	   IF makealias(ALLTRIM(dbflist[m.i,m.pdbfnum])) ;
	         == makealias(ALLTRIM(dbflist[m.dbfnum,m.cstemnum]))
	      RETURN .T.
	   ENDIF
	ENDFOR
	RETURN .F.
	
	*!*****************************************************************
	*!
	*!      Procedure: SHOWTREE
	*!
	*!*****************************************************************
CASE _MAC
	* Does the database at position "dbfnum" of DBFLIST have a child
	* table?
	PRIVATE dbfnum, i
	
	* See if another database has this one as its parent
	FOR m.i = 1 TO m.numareas
	   IF makealias(ALLTRIM(dbflist[m.i,m.pdbfnum])) ;
	         == makealias(ALLTRIM(dbflist[m.dbfnum,m.cstemnum]))
	      RETURN .T.
	   ENDIF
	ENDFOR
	RETURN .F.
	
	*!*****************************************************************
	*!
	*!      Procedure: SHOWTREE
	*!
	*!*****************************************************************
ENDCASE

*       *********************************************************
*       *                                                         
*       *               DBFSELEC Procedure SHOWTREE               
*       *                                                         
*       *********************************************************
*


PROCEDURE SHOWTREE
PARAMETERS DBFNUM, INDENT
DO CASE
CASE _DOS
	PRIVATE dbfnum, indent, m.indchar
	* Recursive routine to display a tree diagram of database relationships.
	
	* The window in which to display the tree must be activated before
	* calling showtree.
	
	IF _MAC OR _WINDOWS
	   m.indchar = "+--"
	ELSE
	   m.indchar = CHR(192)+CHR(196)+CHR(26)
	ENDIF
	
	* First display this database in its correct position on the tree.
	IF WEXIST('treewind')
	   treestr = SPACE(MAX(m.indent-1,0)*3);
	      +IIF(m.indent<>0,m.indchar,'');
	      +dbflist[m.dbfnum,m.cstemnum]
	   end_row = MIN(WLROW('treewind') + 4 + m.nextdbf, SROWS()-1)
	   IF LEN(treestr) >= WCOLS() - 2
	      s_col = WLCOL('treewind')
	      * Move the window to the left if necessary
	      IF s_col + LEN(treestr) + 3 >= SCOLS() - 3
	         s_col = SCOLS() - LEN(treestr) - 6
	      ENDIF
	      ZOOM WINDOW treewind NORM ;
	         FROM WLROW('treewind'),s_col TO end_row, s_col+LEN(treestr)+4
	   ENDIF
	   ? treestr
	ELSE
	   RETURN
	ENDIF
	
	* Find any children of this database and display them
	FOR i = 1 TO m.numareas
	   IF makealias(ALLTRIM(dbflist[m.i,m.pdbfnum])) ;
	         == makealias(ALLTRIM(dbflist[m.dbfnum,m.cstemnum]))
	      DO showtree WITH i, indent + 1
	   ENDIF
	ENDFOR
	
	
CASE _WINDOWS
	PRIVATE dbfnum, indent, m.indchar
	* Recursive routine to display a tree diagram of database relationships.
	
	* The window in which to display the tree must be activated before
	* calling showtree.
	
	IF _MAC
	   m.indchar = "+--"
	ELSE
	   m.indchar = CHR(192)+CHR(196)+CHR(26)
	ENDIF
	
	* First display this database in its correct position on the tree.
	IF WEXIST('treewind')
	   treestr = SPACE(MAX(m.indent-1,0)*3);
	      +IIF(m.indent<>0,m.indchar,'');
	      +dbflist[m.dbfnum,m.cstemnum]
	   end_row = MIN(WLROW('treewind') + 4 + m.nextdbf, SROWS()-1)
	   IF LEN(treestr) >= WCOLS() - 2
	      s_col = WLCOL('treewind')
	      * Move the window to the left if necessary
	      IF s_col + LEN(treestr) + 3 >= SCOLS() - 3
	         s_col = SCOLS() - LEN(treestr) - 6
	      ENDIF
	      ZOOM WINDOW treewind NORM ;
	         FROM WLROW('treewind'),s_col TO end_row, s_col+LEN(treestr)+4
	   ENDIF
	   ? treestr
	ELSE
	   RETURN
	ENDIF
	
	* Find any children of this database and display them
	FOR i = 1 TO m.numareas
	   IF makealias(ALLTRIM(dbflist[m.i,m.pdbfnum])) ;
	         == makealias(ALLTRIM(dbflist[m.dbfnum,m.cstemnum]))
	      DO showtree WITH i, indent + 1
	   ENDIF
	ENDFOR
	
	
CASE _MAC
	PRIVATE dbfnum, indent, m.indchar
	* Recursive routine to display a tree diagram of database relationships.
	
	* The window in which to display the tree must be activated before
	* calling showtree.
	
	IF _MAC
	   m.indchar = "+--"
	ELSE
	   m.indchar = CHR(192)+CHR(196)+CHR(26)
	ENDIF
	
	* First display this database in its correct position on the tree.
	IF WEXIST('treewind')
	   treestr = SPACE(MAX(m.indent-1,0)*3);
	      +IIF(m.indent<>0,m.indchar,'');
	      +dbflist[m.dbfnum,m.cstemnum]
	   end_row = MIN(WLROW('treewind') + 4 + m.nextdbf, SROWS()-1)
	   IF LEN(treestr) >= WCOLS() - 2
	      s_col = WLCOL('treewind')
	      * Move the window to the left if necessary
	      IF s_col + LEN(treestr) + 3 >= SCOLS() - 3
	         s_col = SCOLS() - LEN(treestr) - 6
	      ENDIF
	      ZOOM WINDOW treewind NORM ;
	         FROM WLROW('treewind'),s_col TO end_row, s_col+LEN(treestr)+4
	   ENDIF
	   ? treestr
	ELSE
	   RETURN
	ENDIF
	
	* Find any children of this database and display them
	FOR i = 1 TO m.numareas
	   IF makealias(ALLTRIM(dbflist[m.i,m.pdbfnum])) ;
	         == makealias(ALLTRIM(dbflist[m.dbfnum,m.cstemnum]))
	      DO showtree WITH i, indent + 1
	   ENDIF
	ENDFOR
	
	
ENDCASE